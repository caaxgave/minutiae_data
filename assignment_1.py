# -*- coding: utf-8 -*-
"""Assignment 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YHfW0mU3zPBMzv2C3n6MjKOfGNI2h_h0

# Minutae Features for Latent Fingerprints Code

### Import libraries and data

Libraries and mount google drive
"""

import pandas as pd
import numpy as np
import xml.etree.ElementTree as ET 
!pip install liac-arff
import arff

from cmath import rect, phase
from math import radians, degrees

from scipy.spatial import ConvexHull

from scipy.sparse.csgraph import minimum_spanning_tree
from scipy.sparse import csr_matrix
import networkx as nx
from itertools import combinations



#from google.colab import drive
#drive.mount('/content/drive')

"""Clone Github repository

"""

!git clone https://github.com/caaxgave/minutiae_data

"""Unzip dmc_diff to get XML files

"""

!unzip "/content/minutiae_data/dmc_diff.zip" -d "/content/minutiae_data/"

"""## Import csv data"""

def fingerprint_names(path_csv): #Receives path of the .csv file
  df = pd.read_csv(path_csv)
  return df.fingerprint.unique()

"""## Load XML files"""

def read_XML(path_xml, file_names):
  finger_data = [] #empty array for array form

  for fingerprint in range(len(file_names)):  #iterate file names
    xtree = ET.parse(path_xml + file_names[fingerprint] + ".mntscore")  #read the document
    xroot = xtree.getroot()
    fp_name = file_names[fingerprint] #Get te name of the fingerprint

    for node in xroot:
      s_minutia = node.attrib.get("version")  #Get target minutia
      s_score = node.attrib.get("score")      #Get score
      s_x = node.find("MissingMinutia").attrib.get("x") #Get "x" value 
      s_y = node.find("MissingMinutia").attrib.get("y") #Get "y" value
      s_angle = node.find("MissingMinutia").attrib.get("angle")  #Get angle

      finger_data.append({"fingerprint": str(fp_name),"minutia": str(s_minutia), "x": float(s_x), 
                  "y": float(s_y), "angle": float(s_angle), "score_change": float(s_score)})
  return XML_dataframe(finger_data)

#create dataframe from all XML files
def XML_dataframe(fingerprint_data):
  df_cols = ['fingerprint', 'minutia', 'x', 'y', 'angle', 'score_change']
  df_minutiae = pd.DataFrame(fingerprint_data, columns = df_cols)
  df_minutiae = df_minutiae.apply(categorical_score, axis='columns')
  df_minutiae = df_minutiae.set_index(['fingerprint'])

  return df_minutiae

#transform score_change column to categorical data
def categorical_score(row):
  if row.score_change > 0:
    row.score_change = "+"
  else:
    row.score_change = "-"
  return row

"""## Shared Functions"""

def extract_features(Values, angle=False):
  sorted_values = np.sort(Values)
  
  min_value = min(Values)
  max_value = max(Values)
  avrg_value = np.average(Values)
  variance_value = np.var(Values)
  median_value = np.median(Values)
  #std_value = np.std(Values)
  minmax_ratio = min_value/max_value

  if angle:
    avrg_value = degrees(phase(sum(rect(1, radians(d)) for d in Values)/len(Values)))

  second_min = sorted_values[1]
  second_max = sorted_values[len(Values)-2]

  return [min_value, max_value, avrg_value, variance_value, median_value, minmax_ratio, second_min, second_max]

def distances_fromPoint(fingerprint, reference):
  distances = []
  for idx in range(len(fingerprint)):
    euclidian_distance = np.sqrt(((fingerprint[idx][1] - reference[0])**2) + ((fingerprint[idx][2] - reference[1])**2))
    distances.append(euclidian_distance)
  return distances

def distances_mnht_fromPoint(fingerprint, reference):
  distances = []
  for idx in range(len(fingerprint)):
    manhatan_distance = abs(fingerprint[idx][1] - reference[0]) + abs(fingerprint[idx][2] - reference[1])
    distances.append(manhatan_distance)
  return distances

def features_inside_radius(Values, radius):
  vals = np.array(Values)
  inside = []
  for idx in radius:
    minutiae_inside = vals[vals<=idx]
    if minutiae_inside.shape[0] == 0:
      inside.append(0)
      inside.append(0)
    else:
      inside.append(np.average(minutiae_inside))
      inside.append(minutiae_inside.shape[0])

  return inside

def near_far_minutia(fingerprint, reference_indx):
  minutiae = np.delete(fingerprint, reference_indx, 0)
  ref_minutia = (fingerprint[reference_indx][1], fingerprint[reference_indx][2])
  distan_minutiae = distances_fromPoint(minutiae, ref_minutia)
  near = np.argmin(distan_minutiae)
  far = np.argmax(distan_minutiae)
  if near >= reference_indx:
    near += 1
  if far >= reference_indx:
    far += 1

  return [near, far]

def near_far_features(fingerprint, angle):
  near = []
  far = []

  for idx in range (len(fingerprint)):
    nearfar_idx = near_far_minutia(fingerprint, idx)
    if angle == "beta":
      near.append(compute_beta(fingerprint[idx], fingerprint[nearfar_idx[0]]))
      far.append(compute_beta(fingerprint[idx], fingerprint[nearfar_idx[1]]))
    if angle == "alpha":
      near.append(compute_alpha(fingerprint[idx], fingerprint[nearfar_idx[0]]))
      near.append(compute_alpha(fingerprint[nearfar_idx[0]], fingerprint[idx]))

      far.append(compute_alpha(fingerprint[idx], fingerprint[nearfar_idx[1]]))
      far.append(compute_alpha(fingerprint[nearfar_idx[1]], fingerprint[idx]))

  return [np.average(near), np.var(near), np.average(far), np.var(far)]

def feature_variation(data_before, data_after):
  variation = []
  for idx in range(len(data_before)):
    variation.append(data_after[idx] - data_before[idx])

  return variation

"""## Distances attributes"""

def distances_arrays(fingerprint): 
  euclidian_distances = []
  manhatan_distances = []
  for idx in range(len(fingerprint)-1):
    for idy in range(idx+1, len(fingerprint)):
      euclidian = np.sqrt(((fingerprint[idx][1] - fingerprint[idy][1]) ** 2) + ((fingerprint[idx][2] - fingerprint[idy][2]) ** 2))
      manhatan = abs(fingerprint[idx][1] - fingerprint[idy][1]) + abs(fingerprint[idx][2] - fingerprint[idy][2])
      euclidian_distances.append(euclidian)
      manhatan_distances.append(manhatan)
  
  return euclidian_distances, manhatan_distances


def distances(fingerprint):
  both_distances = distances_arrays(fingerprint)

  return extract_features(both_distances[0])[:6] + extract_features(both_distances[1])[:6]

def target_distances(fingerprint, target_minu):
  target_location = (fingerprint[target_minu][1], fingerprint[target_minu][2])
  distances_eu = distances_fromPoint(np.delete(fingerprint, target_minu, 0), target_location)
  distances_mnht = distances_mnht_fromPoint(np.delete(fingerprint, target_minu, 0), target_location)

  return extract_features(distances_eu)[:6] + extract_features(distances_mnht)[:6]

"""## Beta attributes"""

def beta(fingerprint):
  beta_angles = []
  
  for idx in range(len(fingerprint)-1):
    for idy in range(idx+1, len(fingerprint)):
      beta_angles.append(compute_beta(fingerprint[idx], fingerprint[idy]))
  
  return extract_features(beta_angles, angle=True) + near_far_features(fingerprint, "beta")

def target_beta(fingerprint, target):
  beta_angles = []
  target_point = (fingerprint[target][1], fingerprint[target][2])
  new_set = np.delete(fingerprint, target, 0)
  for idx in range(len(new_set)):
    beta_angles.append(compute_beta(fingerprint[target], new_set[idx]))
  distances_ft = distances_fromPoint(new_set, target_point)

  beta_1nn = beta_angles[np.argmin(distances_ft)]
  beta_2nn = beta_angles[np.argsort(distances_ft)[1]]

  beta_1fn = beta_angles[np.argmax(distances_ft)]
  beta_2fn = beta_angles[np.argsort(distances_ft)[-2]]

  return extract_features(beta_angles, angle=True) + [beta_1nn, beta_2nn, beta_1fn, beta_2fn]

def compute_beta(point_i, point_j):
  b_angle = min(abs(point_i[3] - point_j[3]), (360 - abs(point_i[3] - point_j[3])))
  return b_angle

"""## Alpha angles"""

def alpha(fingerprint):
  alpha_angles = []
  for idx in range(len(fingerprint)-1):
    for idy in range(idx+1, len(fingerprint)):
      alpha_ij = compute_alpha(fingerprint[idx], fingerprint[idy])
      alpha_ji = compute_alpha(fingerprint[idy], fingerprint[idx])
      alpha_angles.append(alpha_ij)
      alpha_angles.append(alpha_ji)

  return extract_features(alpha_angles, angle=True) + near_far_features(fingerprint, "alpha")

def target_alpha(fingerprint, target):
  alpha_angles = []
  target_point = (fingerprint[target][1], fingerprint[target][2])
  new_set = np.delete(fingerprint, target, 0)
  for idx in range(len(new_set)):
    alpha_angles.append(compute_alpha(fingerprint[target], new_set[idx]))
  distances_ft = distances_fromPoint(new_set, target_point)

  alpha_1nn = alpha_angles[np.argmin(distances_ft)]
  alpha_2nn = alpha_angles[np.argsort(distances_ft)[1]]

  alpha_1fn = alpha_angles[np.argmax(distances_ft)]
  alpha_2fn = alpha_angles[np.argsort(distances_ft)[-2]]

  return extract_features(alpha_angles, angle=True) + [alpha_1nn, alpha_2nn, alpha_1fn, alpha_2fn]

def compute_alpha(point_i, point_j):
  ang = ang_angle(point_i, point_j)
  alpha_angle = min(abs(point_i[3] - ang), (360-abs(point_i[3] - ang)))

  return alpha_angle

def ang_angle(minutia_i, minutia_j):
  delta_x = minutia_j[1] - minutia_i[1]
  delta_y = minutia_j[2] - minutia_i[2]

  if (delta_x > 0 and delta_y >= 0):
    ang = np.arctan(delta_y/delta_x)
    return ang

  if (delta_x > 0 and delta_y < 0):
    ang = np.arctan(delta_y/delta_x) + 360
    return ang

  if delta_x < 0:
    ang = np.arctan(delta_y/delta_x) + 180
    return ang

  if delta_x == 0 and delta_y > 0:
    ang = 90
    return ang

  if delta_x == 0 and delta_y < 0:
    ang = 270
    return ang

"""## Centroid"""

def centroid(fingerprint):
  sum_x = np.sum(fingerprint[:,1])
  sum_y = np.sum(fingerprint[:,2])
  set_centroid = (sum_x/fingerprint.shape[0], sum_y/fingerprint.shape[0])
  centroid_distances = distances_fromPoint(fingerprint, set_centroid)
  radius = [30,45,60]
  centroid_inside = features_inside_radius(centroid_distances, radius)
  
  return extract_features(centroid_distances)[:6] + centroid_inside

def target_centroid(fingerprint, target):
  sum_x = np.sum(fingerprint[:,1])
  sum_y = np.sum(fingerprint[:,2])
  set_centroid = (sum_x/fingerprint.shape[0], sum_y/fingerprint.shape[0])
  euclidian_center = np.sqrt(((set_centroid[0] - fingerprint[target][1])**2) + ((set_centroid[1] - fingerprint[target][2])**2))
  manhatan_center = abs(set_centroid[0] - fingerprint[target][1]) + abs(set_centroid[1] - fingerprint[target][2])

  target_centroid_distances = distances_fromPoint(np.delete(fingerprint, target, 0), (fingerprint[target][1], fingerprint[target][2]))
  radius = [30,45,60,95]
  direction = ang_angle([0, set_centroid[0], set_centroid[1], 0], fingerprint[target])

  fingerprint_nt = np.delete(fingerprint, target, 0)
  centroid_nt = (np.sum(fingerprint_nt[:,1])/fingerprint_nt.shape[0], np.sum(fingerprint_nt[:,2])/fingerprint_nt.shape[0])
  euclidian_center_nt = np.sqrt(((centroid_nt[0] - fingerprint[target][1])**2) + ((centroid_nt[1] - fingerprint[target][2])**2))

  return [euclidian_center, manhatan_center, euclidian_center_nt, direction] + features_inside_radius(target_centroid_distances, radius)

"""## Convex Hull"""

def convex_hull(fingerprint):
  points = fingerprint[:,1:3]
  hull = ConvexHull(points)
  convex_points = hull.vertices
  
  perimeter = hull.area
  area = hull.volume
  minutiae_convex = len(convex_points)
  minutiae_inside = len(fingerprint) - minutiae_convex
  
  return [perimeter, area, minutiae_convex, minutiae_inside] + convex_distances(np.array(fingerprint)[convex_points])

def convex_distances(points_convex):
  distances = []
  for idx in range(len(points_convex)-1):
    euclidian = np.sqrt(((points_convex[idx][1] - points_convex[idx+1][1])**2) + ((points_convex[idx][2] - points_convex[idx+1][2])**2) )
    distances.append(euclidian)
  distances.append(np.sqrt(((points_convex[len(points_convex)-1][1] - points_convex[0][1])**2) + ((points_convex[len(points_convex)-1][2] - points_convex[0][2])**2) ))

  return extract_features(distances)

"""## MST"""

def graph_maker(fingerprint):
  minutiae = [i for i in range(len(fingerprint))] #nodes
  distances = distances_arrays(fingerprint)[0] #edges268

  combinations_list = list(combinations(minutiae,2))
  matrix = np.zeros((len(minutiae),len(minutiae)), dtype=int)
  i=0
  for node in combinations_list:
    matrix[node[0]][node[1]] = distances[i]
    i += 1
  
  return matrix.tolist()

def max_branches(mst):
  list1 = list(np.where(mst != 0))[0].tolist()
  list2 = list(np.where(mst != 0))[1].tolist()
  whole_list = list1 + list2 
  index = max(whole_list, key=whole_list.count)
  max_branches = whole_list.count(index)

  first_max_branch_distance = 0
  for i in range(len(mst[0])):
     first_max_branch_distance += mst[index][i] + mst[i][index]

  return [first_max_branch_distance, max_branches]


def number_leafs(mst):
  j, leafs = 0, 0
  list1 = list(np.where(mst != 0))[0].tolist()
  list2 = list(np.where(mst != 0))[1].tolist()
  whole_list = list1 + list2
  for i in range(len(mst[0])):
    if whole_list.count(i) == 1:
      leafs += 1

  return leafs 

def min_spanning_tree(fingerprint):
  graph = csr_matrix(graph_maker(fingerprint))
  mst = minimum_spanning_tree(graph)

  total_distance = np.sum(mst)
  mst = mst.toarray().astype(int)

  return [total_distance, number_leafs(mst)] + max_branches(mst) + extract_features(np.array(mst)[mst > 0])

"""## Get fingerprint data"""

def minutia_features(set_fingerprint):

  distances_ = distances(set_fingerprint.values)
  alpha_ = alpha(set_fingerprint.values)
  beta_ = beta(set_fingerprint.values)
  centroid_ = centroid(set_fingerprint.values)
  convex_hull_ = convex_hull(set_fingerprint.values)
  mst_ = min_spanning_tree(set_fingerprint.values)

  return distances_ + alpha_ + beta_ + centroid_ + convex_hull_ + mst_

def minutia_target_features(set_fingerprint, target_minutia):
  distances_ = target_distances(set_fingerprint.values, target_minutia)
  centroid_ = target_centroid(set_fingerprint.values, target_minutia)
  beta_ = target_beta(set_fingerprint.values, target_minutia)
  alpha_ = target_alpha(set_fingerprint.values, target_minutia)

  return distances_ + alpha_ + beta_ + centroid_

def single_fingerprint_data(set_fingerprint):
  minutiae = set_fingerprint['minutia'].values
  scores = set_fingerprint['score_change'].values
  minu_features = []
  #target_minutia = []
  with_target =  minutia_features(set_fingerprint)  #features all

  for minutia in range(len(minutiae)):
    no_target =  minutia_features(set_fingerprint.loc[set_fingerprint['minutia'] != minutiae[minutia]]) #features no target
    from_target = minutia_target_features(set_fingerprint, minutia)
    variation_target = feature_variation(with_target, no_target)

    minu_features.append([set_fingerprint.index[minutia], minutiae[minutia]] + with_target + variation_target + from_target + [scores[minutia]])
  return minu_features

"""## Create Dataset"""

def create_dataset(xml_df, name):
  fingerprint_features = []
  colms_names = ["fingerprint", "minutia"] + col_names_before() + col_names_variation() + col_names_target() + ["score"]

  for finger_name in range(len(name)):
    minutiae_feature = single_fingerprint_data(xml_df.loc[name[finger_name]])
    fingerprint_features += minutiae_feature
    
  return pd.DataFrame(fingerprint_features, columns=colms_names)

def col_names_before():
  distances_before = ["min_euclidian", "max_euclidian", "avrg_euclidian", "variance_euclidian", "median_euclidian", "minmax_ratio_euclidian",
                      "min_manhatan", "max_manhatan", "avrg_manhatan", "variance_manhatan", "median_manhatan", "minmax_ratio_manhatan"]

  alpha = ["min_alpha", "max_alpha", "avrg_alpha", "variance_alpha", "median_alpha", "minmax_ratio_alpha", "second_min_alpha", "second_max_alpha",
           "avrg_near_alpha", "var_near_alpha", "avrg_far_alpha", "var_far_alpha"]

  beta = ["min_beta", "max_beta", "avrg_beta", "variance_beta", "median_beta", "minmax_ratio_beta", "second_min_beta", "second_max_beta",
           "avrg_near_beta", "var_near_beta", "avrg_far_beta", "var_far_beta"]
  
  centroid = ["min_center", "max_center", "avrg_center", "variance_center", "median_center", "minmax_ratio_center",
              "avrg_r30", "count_r30", "avrg_r45", "count_r45", "avrg_r60", "count_r60"]
      
  convex = ["perimeter", "area", "minutiae_convex", "minutiae_inside", "min_convex", "max_convex", "avrg_convex", "variance_convex", "median_convex", 
            "minmax_ratio_convex", "second_min_convex", "second_max_convex"]

  mst = ["MST_tot_dist", "MST_leafs", "max_branch_distance", "max_branches", "min_MST", "max_MST", "avrg_MST", "variance_MST", "median_MST", 
         "minmax_ratio_MST", "second_min_MST", "second_max_MST"]

  return distances_before + alpha + beta + centroid + convex + mst

def col_names_variation():
  distances_variation = ["min_euclidian_var", "max_euclidian_var", "avrg_euclidian_var", "variance_euclidian_var", "median_euclidian_var", "minmax_ratio_euclidian_var",
                      "min_manhatan_var", "max_manhatan_var", "avrg_manhatan_var", "variance_manhatan_var", "median_manhatan_var", "minmax_ratio_manhatan_var"]

  alpha = ["min_alpha_var", "max_alpha_var", "avrg_alpha_var", "variance_alpha_var", "median_alpha_var", "minmax_ratio_alpha_var", "second_min_alpha_var", "second_max_alpha_var",
           "avrg_near_alpha_var", "var_near_alpha_var", "avrg_far_alpha_var", "var_far_alpha_var"]

  beta = ["min_beta_var", "max_beta_var", "avrg_beta_var", "variance_beta_var", "median_beta_var", "minmax_ratio_beta_var", "second_min_beta_var", "second_max_beta_var",
           "avrg_near_beta_var", "var_near_beta_var", "avrg_far_beta_var", "var_far_beta_var"]

  center = ["min_center_var", "max_center_var", "avrg_center_var", "variance_center_var", "median_center_var", "minmax_ratio_center_var",
              "avrg_r30_var", "count_r30_var", "avrg_r45_var", "count_r45_var", "avrg_r60_var", "count_r60_var"]

  convex = ["perimeter_var", "area_var", "minutiae_convex_var", "minutiae_inside_var", "min_convex_var", "max_convex_var", "avrg_convex_var", "variance_convex_var", 
          "median_convex_var", "minmax_ratio_convex_var", "second_min_convex_var", "second_max_convex_var"]

  mst = ["MST_tot_dist_var", "MST_leafs_var", "max_branch_distance_var", "max_branches_var", "min_MST_var", "max_MST_var", "avrg_MST_var", "variance_MST_var", "median_MST_var", 
         "minmax_ratio_MST_var", "second_min_MST_var", "second_max_MST_var"]

  return distances_variation + alpha + beta + center + convex + mst

def col_names_target():
  distances_target = ["min_euclidian_t", "max_euclidian_t", "avrg_euclidian_t", "variance_euclidian_t", "median_euclidian_t", "minmax_ratio_euclidian_t",
                      "min_manhatan_t", "max_manhatan_t", "avrg_manhatan_t", "variance_manhatan_t", "median_manhatan_t", "minmax_ratio_manhatan_t"]

  alpha = ["min_alpha_t", "max_alpha_t", "avrg_alpha_t", "variance_alpha_t", "median_alpha_t", "minmax_ratio_alpha_t", "second_min_alpha_t", "second_max_alpha_t",
        "alpha_t_1nn", "alpha_t_2nn", "alpha_t_1fn", "alpha_t_2fn"]

  beta = ["min_beta_t", "max_beta_t", "avrg_beta_t", "variance_beta_t", "median_beta_t", "minmax_ratio_beta_t", "second_min_beta_t", "second_max_beta_t",
        "beta_t_1nn", "beta_t_2nn", "beta_t_1fn", "beta_t_2fn"]

  center = ["eucl_center_t", "mnht_center_t","eucl_center_nt", "direction_t", "avrg_r30_t", "count_r30_t", "avrg_r45_t", "count_r45_t", "avrg_r60_t", "count_r60_t",
            "avrg_r75_t", "count_r75_t"]

  return distances_target + alpha + beta + center

"""## Main"""

def save_dataset(Dataframe):
  atributes = [(j, 'NUMERIC') if Dataframe[j].dtypes in ['int64', 'float64'] 
                else (j, Dataframe[j].unique().astype(str).tolist()) for j in Dataframe]

  arff.dump("/content/minutiae_data/fingerprint_dataset.arff",
            Dataframe.values, 
            relation='Fingerprint monitia features',
            names=Dataframe.columns)

def latent_features(path_csv, path_xml):
  names = fingerprint_names(path_csv)
  xml_data = read_XML(path_xml, names)
  final_df = create_dataset(xml_data, names)
  #save_dataset(final_df)
  return final_df

latent_df = latent_features("/content/minutiae_data/index_dmc.csv", "/content/minutiae_data/diff/")

latent_df

latent_df.to_csv("/content/minutiae_data/fingerprint_dataset.csv", encoding='utf-8')

"""## Functions tests

"""

# Commented out IPython magic to ensure Python compatibility.
# %cd minutiae_data/

# Commented out IPython magic to ensure Python compatibility.
# %ls

!pytest main_test.py

"""# **Clases**

## Class Load Data
"""

class LoadData:
  
  def load_csv(self, path_csv):
    df = pd.read_csv(path_csv)
    return df.fingerprint.unique()

  def load_xml(self, path_xml, file_names):
    finger_data = []

    for fingerprint in range(len(file_names)):  #iterate file names
      xtree = ET.parse(path_xml + file_names[fingerprint] + ".mntscore")  #read the document
      xroot = xtree.getroot()
      fp_name = file_names[fingerprint] #Get te name of the fingerprint

      for node in xroot:
        s_minutia = node.attrib.get("version")  #Get target minutia
        s_score = node.attrib.get("score")      #Get score
        s_x = node.find("MissingMinutia").attrib.get("x") #Get "x" value 
        s_y = node.find("MissingMinutia").attrib.get("y") #Get "y" value
        s_angle = node.find("MissingMinutia").attrib.get("angle")  #Get angle

        #Pandas Dataframe form
        finger_data.append({"fingerprint": str(fp_name),"minutia": str(s_minutia), "x": float(s_x), 
                    "y": float(s_y), "angle": float(s_angle), "score": float(s_score)})
    return self.__XML_dataframe(finger_data)

  def __XML_dataframe(self, fingerprint_data):
    df_cols = ['fingerprint', 'minutia', 'x', 'y', 'angle', 'score']
    df_minutiae = pd.DataFrame(fingerprint_data, columns = df_cols)
    df_minutiae = df_minutiae.set_index(['fingerprint'])
    return df_minutiae

"""## Class Fingerprint Distances"""

class FingerprintDistances:

  def distances(self, fingerprint):
    euclidian_distances = []
    manhatan_distances = []

    for idx in range(len(fingerprint)-1):
      for idy in range(idx+1, len(fingerprint)):
        euclidian = np.sqrt(((fingerprint[idx][1] - fingerprint[idy][1]) ** 2) + ((fingerprint[idx][2] - fingerprint[idy][2]) ** 2))
        manhatan = abs(fingerprint[idx][1] - fingerprint[idy][1]) + abs(fingerprint[idx][2] - fingerprint[idy][2])
        euclidian_distances.append(euclidian)
        manhatan_distances.append(manhatan)

    return self.__features_distances(euclidian_distances) + self.__features_distances(manhatan_distances)

  def __features_distances(self, distances_values):
    min_distance = min(distances_values)
    max_distance = max(distances_values)
    avrg_distance = np.average(distances_values)
    variance_distance = np.var(distances_values)
    median_distance = np.median(distances_values)
    std_distance = np.std(distances_values)

    return [min_distance, max_distance, avrg_distance, variance_distance, median_distance, std_distance]

"""## Class Create Dataset"""

class CreateDataset:
  Load_data = LoadData()
  Distances = FingerprintDistances()
  f_names = []
  df_xml = []
  finalDF = []

  def loadCSV(self, path):
    self.f_names = self.Load_data.load_csv(path)

  def loadXML(self, path):
    self.df_xml = self.Load_data.load_xml(path, self.f_names)

  def create_dataset(self):
    fingerprint_features = []

    for finger_name in range(len(self.f_names)):
      minutiae_feature = self.__single_fingerprint_data(self.df_xml.loc[self.f_names[finger_name]])
      fingerprint_features += minutiae_feature
    self.finalDF = pd.DataFrame(fingerprint_features)
      
    return self.finalDF

  def __single_fingerprint_data(self, set_fingerprint):
    minutiae = set_fingerprint['minutia'].values
    scores = set_fingerprint['score'].values
    minu_features = []
    target_minutia = []

    for minutia in range(len(minutiae)):
      with_target =  self.__minutia_features(set_fingerprint)
      no_target =  self.__minutia_features(set_fingerprint.loc[set_fingerprint['minutia'] != minutiae[minutia]])

      minu_features.append([set_fingerprint.index[minutia], minutiae[minutia]] + with_target + no_target + [scores[minutia]])
    return minu_features

  def __minutia_features(self, set_fingerprint):

    distances_ = self.Distances.distances(set_fingerprint.values)
    #beta_ = beta(set_fingerprint.values)
    #centroid_ = centroid(set_fingerprint.values)
    #convex_hull_ = convex_hull(set_fingerprint.values)

    return distances_ #+ beta_ + centroid_ + convex_hull_

var = LoadData()
var.

ld = LoadData()
csv = ld.load_csv("/content/drive/MyDrive/ML2/Assignment1/index_dmc.csv")
xml = ld.load_xml("/content/drive/MyDrive/ML2/Assignment1/dmc_diff/diff/", csv)

datos = XML_dataframe(xml)

distancias = FingerprintDistances()
valores = distancias.distances(datos.values)
valores

Df_creator = CreateDataset()
Df_creator.loadCSV("/content/drive/MyDrive/ML2/Assignment1/index_dmc.csv")
Df_creator.loadXML("/content/drive/MyDrive/ML2/Assignment1/dmc_diff/diff/")
Feature_df = Df_creator.create_dataset()

Feature_df